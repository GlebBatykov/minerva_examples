<div align="center">

**Языки:**
  
[![English](https://img.shields.io/badge/Language-English-blue?style=?style=flat-square)](README.md)
[![Russian](https://img.shields.io/badge/Language-Russian-blue?style=?style=flat-square)](README.ru.md)

</div>

Это пример использования фреймворка [Minerva](https://github.com/GlebBatykov/minerva).

Данный пример содержит многопоточный вебсокет сервер реализованный при помощи `Minerva`, а так же Flutter приложение в качестве клиента взаимодействующего с ним.

Сервер содержит в себе состояние счетчика, позволяет клиентам подключающимся под вебсокетам взаимодействовать и получать данное состояние.

Использования параметра `instance` класса `MinervaSetting` позволяет нам задать количество экземпляров сервера которые будут запущены. Мы указали значение параметра `instance` как `Platform.numberOfProcessors` из библиотеки `dart:io`. Это означает что количество экземпляров сервера будет равно количеству доступных потоков нашего процессора.

Особенности реализации сервера при помощи `Minerva`. При помощи `Minerva` мы запускаем несколько экземпляров нашего сервера, каждый из которых запускается в собственном изоляте. Таким образом каждый экземпляр сервера содержит свое внутреннее состояние. 

Однако для реализации подобного вебсокет сервера нам необходимо чтобы каждый из экземляров сервера взаимодействовал с общим состоянием счетчика. Мы можем добится этого при помощи `агентов`. Мы создаем `агента`, который содержит состояние счетчика, а так же позволяет его изменять и получать.

Хорошо, мы имеем теперь возможность при помощи `агента` взаимодействовать с состоянием общим для каждого из экземпляров сервера. Но из за того что входящее вебсокет подключение может быть обработано любым из экземпляров сервера, каждый из экземпляров сервера взаимодействует с собственными клиентами, подключенными к нему. 

Так как тогда нам в случае изменения их общего состояния уведомлять всех клиентов об этом? Мы можем использовать для этого Send/Receive порты. Используя их мы можем реализовать механизм подписки на состояние `агента`, и затем в случае изменения состояния счетчика, каждый из экземпляров сервера будет уведомлен об этом и уведомит об этом клиентов с которыми он работает.
